<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Qortal Mintership System Members v0.10</title>
    <style>
        /* CSS styles */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            color: var(--text-color, #333);
            background-color: var(--background-color, white);
        }
        .summary {
            margin-bottom: 30px;
        }
        .summary p {
            margin: 5px 0;
        }
        .admin-list, .level-group {
            margin-bottom: 20px;
        }
        .member {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .member img, .member .placeholder {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }
        .member .placeholder {
            background-color: transparent;
        }
        .member .transfer-placeholder {
            width: 80px;
            margin-right: 15px;
            object-fit: cover;
            flex-shrink: 0;
            background-color: transparent;
        }
        .minter-admin {
            font-weight: bold;
            color: var(--link-color, dodgerblue);
        }
        .dev-admin {
            font-weight: bold;
            /* Direct orange color so it isn't overridden by --link-color */
            color: rgb(255, 144, 30);
        }
        .null-acct {
            font-weight: bold;
            /* Direct red color so it isn't overridden by --link-color */
            color: rgb(144, 30, 30);
        }
        h2, h3 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            cursor: pointer;
            user-select: none;
            color: var(--link-color, dodgerblue);
        }
        #loading {
            font-size: 18px;
            color: #555;
        }
        #progress {
            font-size: 16px;
            color: #777;
        }
        #progress-bar-container {
            width: 100%;
            background-color: #ccc;
            border-radius: 5px;
            overflow: hidden;
            height: 20px;
            margin-bottom: 10px;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: dodgerblue;
            transition: width 0.2s ease;
        }
        #estimated-time {
            font-size: 16px;
            color: #777;
        }
        .collapsible {
            cursor: pointer;
            user-select: none;
            position: relative; /* so that ::before can be positioned */
            padding-left: 25px; /* make room for the arrow */
            transition: background-color 0.3s ease;
        }
        .collapsible:hover {
            background-color: #f8f8f8;
        }
        .collapsible::before {
            content: "►";
            position: absolute;
            left: 0;
            top: 50%;
            transform: translateY(-50%);
            font-size: 1.2em; /* size the arrow if desired */
            transition: transform 0.2s ease;
        }
        .collapsible.active::before {
            content: "▼";
        }
        .content {
            display: none;
            padding-left: 15px;
        }
        /* New styles for the tiers */
        .tier {
            margin-bottom: 20px;
        }
        .tier h3 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            color: var(--link-color, dodgerblue);
        }
        .tier p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>Qortal Mintership System Members v0.10</h1>
    <div><button id="reload-button" type="button" disabled>Reload</button><span id="loading">Loading data...</span></div>
    <div class="summary" style="display:none;">
        <!-- New elements for block and payout info -->
        <table>
            <tr><td>Current Reward</td><td><span id="current-block-reward"></span></td></tr>
            <tr><td>Current Payout</td><td><span id="current-block-payout"></span></td></tr>
            <tr><td>Current Height</td><td><span id="current-block-height"></span></td></tr>
            <tr><td>Next Payout</td><td><span id="next-payout-height"></span></td></tr>
            <tr><td><span id="blocks-until-payout"></span></td><td><span id="time-until-payout"></span></td></tr>
        </table>
        <hr>
        <p>Total Minter Group Members: <span id="total-members"></span></p>
        <div id="progress">
            <p id="progress-text"></p>
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>
            <p id="estimated-time"></p>
        </div>
        <!-- Collapsible headings for Minter/Admin lists -->
        <h2 id="minter-admins-header" class="collapsible">
            Minter Admins (<span id="total-minter-admins"></span>) - Group ID 694
        </h2>
        <div id="minter-admins-content" class="content">
            <div id="minter-admin-list"></div>
        </div>
        <h2 id="dev-admins-header" class="collapsible">
            Developer Admins (<span id="total-dev-admins"></span>) - Group ID 1
        </h2>
        <div id="dev-admins-content" class="content">
            <div id="dev-admin-list"></div>
        </div>
    </div>
    <!-- New div for rewards by tier -->
    <div id="rewards-by-tier" style="display:none;">
        <!-- Rewards per tier will be inserted here -->
    </div>
    <!-- Add search input field -->
    <p>
        <input type="text" id="search-input" placeholder="Search members...">
    </p>
    <div id="members-by-level" style="display:none;">
        <!-- Members grouped by level will be inserted here -->
    </div>
    <script>
        // JavaScript code

        const membersByLevel = {};
        let minterAdmins = [];
        let devAdmins = [];
        let tierData = {};
        // Create caches so you only ever fetch each piece of data once per address:
        const addressCache = new Map();
        const nameCache = new Map();
        nameCache.set('QdSnUy6sUiEnaN87dWmE92g1uQjrvPgrWG', '[Null Account]');
        const transferPrivsCache = new Map();

        const loadingDiv = document.getElementById('loading');
        const summaryDiv = document.querySelector('.summary');
        const membersByLevelContainer = document.getElementById('members-by-level');
        const progressDiv = document.getElementById('progress');
        const progressText = document.getElementById('progress-text');
        const progressBar = document.getElementById('progress-bar');
        const estimatedTimeDiv = document.getElementById('estimated-time');
        const minterAdminListDiv = document.getElementById('minter-admin-list');
        const devAdminListDiv = document.getElementById('dev-admin-list');
        const rewardsByTierContainer = document.getElementById('rewards-by-tier');
        const searchInput = document.getElementById('search-input');

        // Theme variables from Q-Apps
        const theme = typeof _qdnTheme !== 'undefined' ? _qdnTheme : 'light';

        // Set CSS variables based on theme
        if (theme === 'dark') {
            document.documentElement.style.setProperty('--background-color', '#001f3f');
            document.documentElement.style.setProperty('--text-color', '#e0e0e0');
            document.documentElement.style.setProperty('--link-color', 'dodgerblue');
        } else {
            document.documentElement.style.setProperty('--background-color', 'white');
            document.documentElement.style.setProperty('--text-color', '#333');
            document.documentElement.style.setProperty('--link-color', 'dodgerblue');
        }

        (async () => {
            try {
                // Fetch the group members data
                const response = await fetch('/groups/members/694');
                if (!response.ok) throw new Error('Failed to fetch group members');
                const data = await response.json();

                const memberCount = data.memberCount;
                const minterAdminCount = data.adminCount;
                const members = data.members; // Array of member objects

                // Display the total members and admins
                document.getElementById('total-members').textContent = memberCount;
                document.getElementById('total-minter-admins').textContent = minterAdminCount;

                const devResponse = await fetch('/groups/members/1');
                if (!devResponse.ok) throw new Error('Failed to fetch dev group members');
                const devData = await devResponse.json();
                const devAdminCount = devData.adminCount;
                const devMembers = devData.members; // Array of dev group member objects
                devAdmins = devMembers.filter(member => member.isAdmin);
                document.getElementById('total-dev-admins').textContent = devAdminCount;
                // Once the DOM elements exist, attach click handlers for toggling:
                document.getElementById('minter-admins-header').addEventListener('click', function() {
                    const contentDiv = document.getElementById('minter-admins-content');
                    if (contentDiv.style.display === 'block') {
                        contentDiv.style.display = 'none';
                        this.classList.remove('active');
                    } else {
                        contentDiv.style.display = 'block';
                        this.classList.add('active');
                    }
                });
                document.getElementById('dev-admins-header').addEventListener('click', function() {
                    const contentDiv = document.getElementById('dev-admins-content');
                    if (contentDiv.style.display === 'block') {
                        contentDiv.style.display = 'none';
                        this.classList.remove('active');
                    } else {
                        contentDiv.style.display = 'block';
                        this.classList.add('active');
                    }
                });
                devAdmins = await Promise.all(
                    devAdmins.map(async (adminObj) => {
                        return processDevAdmin(adminObj);
                    })
                );

                summaryDiv.style.display = 'block';

                // Update block info and get necessary variables
                const blockInfo = await updateBlockInfo();

                // Total payout reward for next payout
                const totalPayoutReward = 1000 * blockInfo.currentBlockReward;

                // Store the total payout reward in a global variable
                window.totalPayoutRewardGlobal = totalPayoutReward;

                // Define tiers
                const tiers = [
                    { levels: [1,2], percentage: 0.06, name: 'Levels 1-2' },
                    { levels: [3,4], percentage: 0.13, name: 'Levels 3-4' },
                    { levels: [5,6], percentage: 0.19, name: 'Levels 5-6' },
                    { levels: [7,8], percentage: 0.26, name: 'Levels 7-8' },
                    { levels: [9,10], percentage: 0.32, name: 'Levels 9-10' },
                ];

                tierData = {};

                tiers.forEach(tier => {
                    tierData[tier.name] = {
                        percentage: tier.percentage,
                        levels: tier.levels,
                        memberCount: 0,
                        reward: 0,
                        rewardPerMember: 0
                    };
                });

                const startTime = Date.now();
                // Process each member
                const totalMembers = members.length;
                let processedMembers = 0;

                // Limit the number of concurrent fetches
                const CONCURRENT_LIMIT = 10;
                let index = 0;

                async function processNext() {
                    if (index >= members.length) {
                        return;
                    }
                    const memberObj = members[index];
                    index++;
                    await processMember(memberObj);
                    processedMembers++;
                    const percentage = ((processedMembers / totalMembers) * 100).toFixed(2);
                    const elapsedTime = Date.now() - startTime; // in milliseconds
                    const averageTimePerMember = elapsedTime / processedMembers;
                    const estimatedTotalTime = averageTimePerMember * totalMembers;
                    const estimatedTimeRemaining = estimatedTotalTime - elapsedTime; // in milliseconds
                    progressText.textContent = `Processed ${processedMembers} of ${totalMembers} members (${percentage}%)`;
                    progressBar.style.width = `${percentage}%`;
                    estimatedTimeDiv.textContent = `Estimated Time Remaining: ${formatTime(estimatedTimeRemaining / 1000)}`;
                    await processNext();
                }

                // Start initial concurrent fetches
                const initialPromises = [];
                for (let i = 0; i < CONCURRENT_LIMIT; i++) {
                    initialPromises.push(processNext());
                }

                await Promise.all(initialPromises);

                // All members processed

                // This hides the progress indicators
                loadingDiv.textContent = '';
                membersByLevelContainer.style.display = 'block';
                progressDiv.style.display = 'none';

                // Now, display the data

                // Compute member counts per tier
                minterAdmins = [];
                for (const level in membersByLevel) {
                    // Build minterAdmins from the fully processed members:
                    for (const memberObj of membersByLevel[level]) {
                        if (memberObj.isAdmin) {
                            minterAdmins.push(memberObj);
                        }
                    }
                    const levelNum = parseInt(level, 10);
                    const memberCountAtLevel = membersByLevel[level].length;
                    for (const tier of tiers) {
                        if (tier.levels.includes(levelNum)) {
                            tierData[tier.name].memberCount += memberCountAtLevel;
                            break;
                        }
                    }
                }

                // Adjust top tiers if they have fewer than 30 members
                const topTier910 = tierData['Levels 9-10'];
                const nextTier78 = tierData['Levels 7-8'];
                const nextDown56 = tierData['Levels 5-6'];

                if (topTier910.memberCount < 30) {
                    const sum = nextTier78.percentage + topTier910.percentage;
                    // Round to two decimals:
                    nextTier78.percentage = parseFloat(sum.toFixed(2));
                    topTier910.percentage = 0;
                }

                if (nextTier78.memberCount < 30) {
                    const sum = nextDown56.percentage + nextTier78.percentage;
                    // Round to two decimals:
                    nextDown56.percentage = parseFloat(sum.toFixed(2));
                    nextTier78.percentage = 0;
                }

                // Now compute rewards per tier
                for (const tierName in tierData) {
                    const tier = tierData[tierName];
                    tier.reward = totalPayoutReward * tier.percentage;
                    if (tier.memberCount > 0) {
                        tier.rewardPerMember = tier.reward / tier.memberCount;
                    } else {
                        tier.rewardPerMember = 0;
                    }
                }

                // Display the rewards per tier
                displayRewardsByTier();

                displayMinterAdmins();
                displayDevAdmins();
                displayMembersByLevel();

                loadingDiv.textContent = '';
                membersByLevelContainer.style.display = 'block';
                progressDiv.style.display = 'none';

            } catch (error) {
                console.error('Error loading data:', error);
                loadingDiv.textContent = `Error loading data: ${error}`;
            }
        })();

        async function updateBlockInfo() {
    try {
        document.getElementById('reload-button').disabled = true;
        loadingDiv.textContent = 'Loading data...';
        // Fetch the current block height
        const blockHeightResponse = await fetch('/blocks/height');
        if (!blockHeightResponse.ok) throw new Error('Failed to fetch block height');
        const currentBlockHeight = await blockHeightResponse.json();

        // Fetch the current block to get its timestamp
        const currentBlockResponse = await fetch(`/blocks/byheight/${currentBlockHeight}`);
        if (!currentBlockResponse.ok) throw new Error('Failed to fetch current block data');
        const currentBlockData = await currentBlockResponse.json();
        const currentBlockTimestamp = currentBlockData.timestamp;

        // Fetch the block at height (currentBlockHeight - 1000) to get its timestamp
        const previousBlockHeight = currentBlockHeight - 1000;
        if (previousBlockHeight <= 0) throw new Error('Not enough blocks to calculate average block time');
        const previousBlockResponse = await fetch(`/blocks/byheight/${previousBlockHeight}`);
        if (!previousBlockResponse.ok) throw new Error('Failed to fetch previous block data');
        const previousBlockData = await previousBlockResponse.json();
        const previousBlockTimestamp = previousBlockData.timestamp;

        // Calculate average block time in seconds per block
        const timeDifferenceInSeconds = (currentBlockTimestamp - previousBlockTimestamp) / 1000;
        const averageBlockTime = timeDifferenceInSeconds / 1000;

        // Calculate next payout block height
        const nextPayoutHeight = Math.ceil(currentBlockHeight / 1000) * 1000;

        // Calculate blocks until next payout
        const blocksUntilPayout = nextPayoutHeight - currentBlockHeight;

        // Estimate time until next payout in seconds
        const estimatedTimeUntilPayout = blocksUntilPayout * averageBlockTime;

        // Function to get the current block reward based on block height
        function getCurrentBlockReward(blockHeight) {
            if (blockHeight >= 3110401) {
                return 2.00;
            } else if (blockHeight >= 2851201) {
                return 2.25;
            } else if (blockHeight >= 2592001) {
                return 2.50;
            } else if (blockHeight >= 2332801) {
                return 2.75;
            } else if (blockHeight >= 2073601) {
                return 3.00;
            } else if (blockHeight >= 1814401) {
                return 3.25;
            } else if (blockHeight >= 1555201) {
                return 3.50;
            } else if (blockHeight >= 1296001) {
                return 3.75;
            } else if (blockHeight >= 1036801) {
                return 4.00;
            } else if (blockHeight >= 777601) {
                return 4.25;
            } else if (blockHeight >= 518401) {
                return 4.50;
            } else if (blockHeight >= 259201) {
                return 4.75;
            } else {
                return 5.00;
            }
        }

        const currentBlockReward = getCurrentBlockReward(nextPayoutHeight);

        // Display block and payout information
        document.getElementById('current-block-reward').textContent = `${currentBlockReward} QORT/Block`;
        document.getElementById('current-block-payout').textContent = `${currentBlockReward*1000} QORT/1000 Blocks`;
        document.getElementById('current-block-height').textContent = `Block ${currentBlockHeight}`;
        document.getElementById('next-payout-height').textContent = `Block ${nextPayoutHeight}`;
        document.getElementById('blocks-until-payout').textContent = `- in ${blocksUntilPayout} Blocks`;
        document.getElementById('time-until-payout').textContent = `(about ${formatTime(estimatedTimeUntilPayout)})`;
        loadingDiv.textContent = '';
        document.getElementById('reload-button').disabled = false;

        // Return the necessary variables for further calculations
        return {
            currentBlockReward,
            currentBlockHeight,
            nextPayoutHeight,
            blocksUntilPayout,
            estimatedTimeUntilPayout
        };
    } catch (error) {
        console.error('Error updating block info:', error);
        loadingDiv.textContent = `Error updating block info: ${error}`;
        document.getElementById('reload-button').disabled = false;
    }
}

        async function processMember(memberObj) {
            const address = memberObj.member;
            // === Address info ===
            if (!addressCache.has(address)) {
                try {
                    const addressDataRes = await fetch(`/addresses/${address}`);
                    if (addressDataRes.ok) {
                        addressCache.set(address, await addressDataRes.json());
                    } else {
                        addressCache.set(address, null);
                    }
                } catch {
                    addressCache.set(address, null);
                }
            }
            const addressData = addressCache.get(address);
            // Get level from the cached addressData
            const level = addressData ? addressData.level : 'Unknown';
            // === Name info ===
            if (!nameCache.has(address)) {
                try {
                    const namesDataRes = await fetch(`/names/address/${address}`);
                    if (namesDataRes.ok) {
                        const namesArray = await namesDataRes.json();
                        nameCache.set(address, (namesArray && namesArray.length) ? namesArray[0].name : null);
                    } else {
                        nameCache.set(address, null);
                    }
                } catch {
                    nameCache.set(address, null);
                }
            }
            const name = nameCache.get(address);

            // === Transfer privs ===
            if (!transferPrivsCache.has(address)) {
                try {
                    const transferCheck = await fetch(`/transactions/search?txType=TRANSFER_PRIVS&confirmationStatus=CONFIRMED&limit=0&address=${address}`);
                    if (transferCheck.ok) {
                        const transferResults = await transferCheck.json();
                        transferPrivsCache.set(address, transferResults);
                        // If there's at least one TRANSFER_PRIVS transaction, fetch the name of the creatorAddress
                        if (transferResults.length > 0) {
                            const creatorAddr = transferResults[0].creatorAddress;
                            const transferNamesDataResponse = await fetch(`/names/address/${creatorAddr}`);
                            if (transferNamesDataResponse.ok) {
                                const transferNamesData = await transferNamesDataResponse.json();
                                // Attach creatorName to the same object
                                transferResults[0].creatorName = (transferNamesData && transferNamesData.length > 0) ? transferNamesData[0].name : null;
                            }
                        }
                    } else {
                        transferPrivsCache.set(address, []);
                    }
                } catch {
                    transferPrivsCache.set(address, []);
                }
            }
            const transferPrivsInfo = transferPrivsCache.get(address);

            // === Avatar URL (no extra fetch check) ===
            // If user has a name, assume an avatar might exist
            let avatarUrl = null;
            if (name) {
                avatarUrl = `/arbitrary/THUMBNAIL/${encodeURIComponent(name)}/qortal_avatar`;
            }
    
            // Build final object
            const memberData = {
                address,
                name,
                level,
                avatarUrl,
                isAdmin: memberObj.isAdmin,
                transferAddress: transferPrivsInfo.length > 0 ? transferPrivsInfo[0].creatorAddress : null,
                transferName: transferPrivsInfo.length > 0 ? transferPrivsInfo[0].creatorName : null,
            };

            // Push to membersByLevel, etc.
            if (!membersByLevel[level]) {
                membersByLevel[level] = [];
            }
            membersByLevel[level].push(memberData);
        }

        async function processDevAdmin(adminObj) {
            try {
                const address = adminObj.member; // original property is .member
                let level = 'Unknown';
                let name = null;
                let avatarUrl = null;
                try {
                    const addressDataResponse = await fetch(`/addresses/${address}`);
                    if (addressDataResponse.ok) {
                        const addressData = await addressDataResponse.json();
                        level = addressData.level;
                    }
                } catch (err) {
                    console.error(`Error fetching address data for ${address}:`, err);
                }
                // 2) Fetch names data => get name
                try {
                    const namesDataResponse = await fetch(`/names/address/${address}`);
                    if (namesDataResponse.ok) {
                        const namesData = await namesDataResponse.json();
                        name = (namesData && namesData.length > 0) ? namesData[0].name : null;
                    }
                } catch (err) {
                    console.error(`Error fetching names data for ${address}:`, err);
                }
                // 3) Check avatar
                if (name) {
                    // The avatar image URL is "/arbitrary/THUMBNAIL/{NAME}/qortal_avatar"
                    const avatarImageUrl = `/arbitrary/THUMBNAIL/${encodeURIComponent(name)}/qortal_avatar`;
                    try {
                        const avatarRes = await fetch(avatarImageUrl);
                        if (avatarRes.ok) {
                            avatarUrl = avatarImageUrl;
                        }
                    } catch (err) {
                        console.error(`Error fetching dev avatar for ${name}:`, err);
                    }
                }
                if (address === 'QdSnUy6sUiEnaN87dWmE92g1uQjrvPgrWG') {
                    name = '[Null Account]'
                }
                // Attach fields so that displayDevAdmins can use them
                // (We rename adminObj.member -> adminObj.address)
                adminObj.address = address;
                adminObj.name = name;
                adminObj.level = level;
                adminObj.avatarUrl = avatarUrl;
                return adminObj;
            } catch (err) {
                console.error(`Error in processDevAdmin():`, err);
                return adminObj; // fallback
            }
        }

        function displayMinterAdmins() {
            if (minterAdmins.length === 0) {
                const p = document.createElement('p');
                p.textContent = 'No minter admins found.';
                minterAdminListDiv.appendChild(p);
                return;
            }

            const totalMinterAdminReward = 0.015 * window.totalPayoutRewardGlobal;
            const rewardPerMinterAdmin = minterAdmins.length ? (totalMinterAdminReward / (minterAdmins.length - 1)) : 0;

            const adminRewardP = document.createElement('p');
            adminRewardP.textContent = `Total Reward for Admins (1.5%): ${totalMinterAdminReward.toFixed(2)} QORT`;

            const adminRewardPerP = document.createElement('p');
            adminRewardPerP.textContent = `Reward per Admin: ${rewardPerMinterAdmin.toFixed(4)} QORT`;

            // Calculate signatures needed
            const signaturesNeeded = Math.ceil(minterAdmins.length * 0.4);
            const pSignatures = document.createElement('p');
            pSignatures.textContent = `Signatures for 40% Group Approval: ${signaturesNeeded}`;
            // Insert it right after the h2 element
            const minterAdminsHeader = document.getElementById('minter-admins-header');
            minterAdminsHeader.parentNode.insertBefore(pSignatures, minterAdminsHeader.nextSibling);
            minterAdminsHeader.parentNode.insertBefore(adminRewardPerP, minterAdminsHeader.nextSibling);
            minterAdminsHeader.parentNode.insertBefore(adminRewardP, minterAdminsHeader.nextSibling);

            // Sort admins alphabetically by name, then by address
            minterAdmins.sort((a, b) => {
                if (a.name && b.name) {
                    return a.name.localeCompare(b.name);
                } else if (a.name) {
                    return -1;
                } else if (b.name) {
                    return 1;
                } else {
                    return a.address.localeCompare(b.address);
                }
            });

            minterAdmins.forEach(admin => {
                const minterAdminDiv = document.createElement('div');
                minterAdminDiv.classList.add('member');

                const img = document.createElement('img');
                img.src = admin.avatarUrl || '/path/to/dummy/image';
                img.alt = `${admin.name || admin.address}'s avatar`;
                img.onerror = function() {
                    // Replace failed image with placeholder div
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('placeholder');
                    this.parentNode.replaceChild(placeholder, this);
                };
                minterAdminDiv.appendChild(img);

                const infoSpan = document.createElement('span');
                let displayText = '';
                if (admin.name) {
                    displayText = `${admin.name} (${admin.address}) - Level ${admin.level}`;
                } else {
                    displayText = `${admin.address} - Level ${admin.level}`;
                }
                infoSpan.textContent = displayText;
                if (admin.address === 'QdSnUy6sUiEnaN87dWmE92g1uQjrvPgrWG') {
                    infoSpan.classList.add('null-acct');
                } else {
                    infoSpan.classList.add('minter-admin');
                }

                minterAdminDiv.appendChild(infoSpan);

                minterAdminListDiv.appendChild(minterAdminDiv);
            });
        }

        function displayDevAdmins() {
            if (devAdmins.length === 0) {
                const p = document.createElement('p');
                p.textContent = 'No developer admins found.';
                devAdminListDiv.appendChild(p);
                return;
            }

            const totalDevAdminReward = 0.015 * window.totalPayoutRewardGlobal;
            const rewardPerDevAdmin = devAdmins.length ? (totalDevAdminReward / (devAdmins.length - 1)) : 0;

            const adminRewardP = document.createElement('p');
            adminRewardP.textContent = `Total Reward for Admins (1.5%): ${totalDevAdminReward.toFixed(2)} QORT`;

            const adminRewardPerP = document.createElement('p');
            adminRewardPerP.textContent = `Reward per Admin: ${rewardPerDevAdmin.toFixed(4)} QORT`;

            // Calculate signatures needed
            const signaturesNeeded = Math.ceil(devAdmins.length * 0.4);
            const pSignatures = document.createElement('p');
            pSignatures.textContent = `Signatures for 40% Group Approval: ${signaturesNeeded}`;
            // Insert it right after the h2 element
            const devAdminsHeader = document.getElementById('dev-admins-header');
            devAdminsHeader.parentNode.insertBefore(pSignatures, devAdminsHeader.nextSibling);
            devAdminsHeader.parentNode.insertBefore(adminRewardPerP, devAdminsHeader.nextSibling);
            devAdminsHeader.parentNode.insertBefore(adminRewardP, devAdminsHeader.nextSibling);

            // Sort dev admins alphabetically by name, then by address
            devAdmins.sort((a, b) => {
                if (a.name && b.name) {
                    return a.name.localeCompare(b.name);
                } else if (a.name) {
                    return -1;
                } else if (b.name) {
                    return 1;
                } else {
                    return a.address.localeCompare(b.address);
                }
            });

            devAdmins.forEach(admin => {
                const devAdminDiv = document.createElement('div');
                devAdminDiv.classList.add('member');

                const img = document.createElement('img');
                img.src = admin.avatarUrl || '/path/to/dummy/image';
                img.alt = `${admin.name || admin.address}'s avatar`;
                img.onerror = function() {
                    // Replace failed image with placeholder div
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('placeholder');
                    this.parentNode.replaceChild(placeholder, this);
                };
                devAdminDiv.appendChild(img);

                const infoSpan = document.createElement('span');
                let displayText = '';
                if (admin.name) {
                    displayText = `${admin.name} (${admin.address}) - Level ${admin.level}`;
                } else {
                    displayText = `${admin.address} - Level ${admin.level}`;
                }
                infoSpan.textContent = displayText;
                if (admin.address === 'QdSnUy6sUiEnaN87dWmE92g1uQjrvPgrWG') {
                    infoSpan.classList.add('null-acct');
                } else {
                    infoSpan.classList.add('dev-admin');
                }

                devAdminDiv.appendChild(infoSpan);

                devAdminListDiv.appendChild(devAdminDiv);
            });
        }

        // Add event listener to the search input
            searchInput.addEventListener('input', function() {
            const searchQuery = searchInput.value.trim().toLowerCase();
            displayMembersByLevel(searchQuery);
        });

        // Modified displayMembersByLevel function
        function displayMembersByLevel(searchQuery = '') {
            // Clear the container
            membersByLevelContainer.innerHTML = '';

            const levels = Object.keys(membersByLevel).sort((a, b) => a - b);

            levels.forEach(level => {
                const membersAtLevel = membersByLevel[level].slice(); // Copy the array
                // Sort members
                membersAtLevel.sort((a, b) => {
                    if (a.name && b.name) {
                        return a.name.localeCompare(b.name);
                    } else if (a.name) {
                        return -1;
                    } else if (b.name) {
                        return 1;
                    } else {
                        return a.address.localeCompare(b.address);
                    }
                });

                // Filter members based on search query
                const filteredMembers = membersAtLevel.filter(member => {
                    if (searchQuery === '') return true;
                    const name = member.name ? member.name.toLowerCase() : '';
                    const address = member.address.toLowerCase();
                    return name.includes(searchQuery) || address.includes(searchQuery);
                });

                if (filteredMembers.length === 0) {
                    // No members matching the search query at this level
                    return; // Skip this level
                }

                const levelGroup = document.createElement('div');
                levelGroup.classList.add('level-group');

                const levelHeader = document.createElement('h2');
                levelHeader.textContent = `Level ${level} Members (${filteredMembers.length})`;
                levelHeader.classList.add('collapsible');

                // Content div that will hold the list of members
                const contentDiv = document.createElement('div');
                contentDiv.classList.add('content');

                filteredMembers.forEach(member => {
                    const memberDiv = document.createElement('div');
                    memberDiv.classList.add('member');

                    const img = document.createElement('img');
                    img.src = member.avatarUrl || '/path/to/dummy/image';
                    img.alt = `${member.name || member.address}'s avatar`;
                    img.onerror = function() {
                        // Replace failed image with placeholder div
                        const placeholder = document.createElement('div');
                        placeholder.classList.add('placeholder');
                        this.parentNode.replaceChild(placeholder, this);
                    };
                    memberDiv.appendChild(img);

                    const nameSpan = document.createElement('span');
                    if (member.name) {
                        nameSpan.textContent = `${member.name} (${member.address})`;
                    } else {
                        nameSpan.textContent = member.address;
                    }

                    // Check for Null Account first
                    if (member.address === 'QdSnUy6sUiEnaN87dWmE92g1uQjrvPgrWG') {
                        nameSpan.classList.add('null-acct');
                    // Check if member is a dev admin...
                    } else if (devAdmins.some(admin => admin.address === member.address)) {
                        nameSpan.classList.add('dev-admin');
                    // ...if not, check if member is a minter admin
                    } else if (member.isAdmin) {
                        nameSpan.classList.add('minter-admin');
                    }

                    memberDiv.appendChild(nameSpan);
                    contentDiv.appendChild(memberDiv);

                    if (member.transferAddress) {
                        const transferDiv = document.createElement('div');
                        transferDiv.classList.add('member');
                        const placeholder = document.createElement('div');
                        placeholder.classList.add('transfer-placeholder');
                        transferDiv.appendChild(placeholder);

                        const transferSpan = document.createElement('span');
                        if (member.transferName) {
                            transferSpan.textContent = `TRANSFER_PRIVS from: ${member.transferName} (${member.transferAddress})`;
                        } else {
                            transferSpan.textContent = `TRANSFER_PRIVS from: (${member.transferAddress})`;
                        }
                        transferDiv.appendChild(transferSpan);
                        contentDiv.appendChild(transferDiv);
                    }

                    
                });

                // Add event listener to level header for collapsing/expanding
                levelHeader.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (contentDiv.style.display === 'block') {
                        contentDiv.style.display = 'none';
                    } else {
                        contentDiv.style.display = 'block';
                    }
                });

                // Expand the level by default if search query is not empty
                if (searchQuery !== '') {
                    contentDiv.style.display = 'block';
                }

                levelGroup.appendChild(levelHeader);
                levelGroup.appendChild(contentDiv);

                membersByLevelContainer.appendChild(levelGroup);
            });
        }

        // Function to format time from seconds to a readable format
        function formatTime(seconds) {
            const days = Math.floor(seconds / (24 * 3600));
            seconds %= (24 * 3600);
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds = Math.floor(seconds % 60);
            let timeString = '';
            if (days > 0) timeString += days + 'd ';
            if (hours > 0 || days > 0) timeString += hours + 'h ';
            if (minutes > 0 || hours > 0 || days > 0) timeString += minutes + 'm ';
            timeString += seconds + 's';
            return timeString;
        }

        // Function to display rewards by tier
        function displayRewardsByTier() {
            for (const tierName in tierData) {
                const tier = tierData[tierName];

                const tierDiv = document.createElement('div');
                tierDiv.classList.add('tier');

                const header = document.createElement('h3');
                header.textContent = `${tierName} - ${tier.memberCount} Members`;
                tierDiv.appendChild(header);

                const rewardP = document.createElement('p');
                rewardP.textContent = `Total Reward for Tier (${(tier.percentage * 100).toFixed(0)}%): ${tier.reward.toFixed(2)} QORT`;
                tierDiv.appendChild(rewardP);

                const rewardPerMemberP = document.createElement('p');
                rewardPerMemberP.textContent = `Reward per Member: ${tier.rewardPerMember.toFixed(4)} QORT`;
                tierDiv.appendChild(rewardPerMemberP);

                rewardsByTierContainer.appendChild(tierDiv);
            }

            rewardsByTierContainer.style.display = 'block';
        }

        // Add event listener to the Reload button
        document.getElementById('reload-button').addEventListener('click', function() {
            updateBlockInfo();
        });

        // TODO:
        // About page
        // Login:
        // - Highlight account
        // - Check invites
        // - Apply to mint
        // - - Check QM/QMM version numbers
        // Duplicate check
        // Dev group members
        // QORTerings
    </script>
</body>
</html>

