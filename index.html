<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Qortal Mintership System Members v0.9</title>
    <style>
        /* CSS styles */
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
            color: var(--text-color, #333);
            background-color: var(--background-color, white);
        }
        .summary {
            margin-bottom: 30px;
        }
        .summary p {
            margin: 5px 0;
        }
        .admin-list, .level-group {
            margin-bottom: 20px;
        }
        .member {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
        }
        .member img, .member .placeholder {
            width: 50px;
            height: 50px;
            margin-right: 15px;
            border-radius: 50%;
            object-fit: cover;
            flex-shrink: 0;
        }
        .member .placeholder {
            background-color: transparent;
        }
        .minter-admin {
            font-weight: bold;
            color: var(--link-color, dodgerblue);
        }
        .dev-admin {
            font-weight: bold;
            /* Direct orange color so it isn't overridden by --link-color */
            color: rgb(255, 144, 30);
        }
        h2, h3 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            cursor: pointer;
            user-select: none;
            color: var(--link-color, dodgerblue);
        }
        #loading {
            font-size: 18px;
            color: #555;
        }
        #progress {
            font-size: 16px;
            color: #777;
        }
        #progress-bar-container {
            width: 100%;
            background-color: #ccc;
            border-radius: 5px;
            overflow: hidden;
            height: 20px;
            margin-bottom: 10px;
        }
        #progress-bar {
            width: 0%;
            height: 100%;
            background-color: dodgerblue;
            transition: width 0.2s ease;
        }
        #estimated-time {
            font-size: 16px;
            color: #777;
        }
        .collapsible {
            cursor: pointer;
            user-select: none;
        }
        .content {
            display: none;
            padding-left: 15px;
        }
        /* New styles for the tiers */
        .tier {
            margin-bottom: 20px;
        }
        .tier h3 {
            border-bottom: 1px solid #ccc;
            padding-bottom: 5px;
            color: var(--link-color, dodgerblue);
        }
        .tier p {
            margin: 5px 0;
        }
    </style>
</head>
<body>
    <h1>Qortal Mintership System Members v0.9</h1>
    <div><button id="reload-button" type="button" disabled>Reload</button><span id="loading">Loading data...</span></div>
    <div class="summary" style="display:none;">
        <!-- New elements for block and payout info -->
        <table>
            <tr><td>Current Reward</td><td><span id="current-block-reward"></span></td></tr>
            <tr><td>Current Height</td><td><span id="current-block-height"></span></td></tr>
            <tr><td>Next Payout</td><td><span id="next-payout-height"></span></td></tr>
            <tr><td><span id="blocks-until-payout"></span></td><td><span id="time-until-payout"></span></td></tr>
        </table>
        <hr>
        <p>Total Members: <span id="total-members"></span></p>
        <div id="progress">
            <p id="progress-text"></p>
            <div id="progress-bar-container">
                <div id="progress-bar"></div>
            </div>
            <p id="estimated-time"></p>
        </div>
        <!-- Collapsible headings for Minter/Admin lists -->
        <h2 id="minter-admins-header" class="collapsible">
            Minter Admins (<span id="total-minter-admins"></span>) - Group ID 694
        </h2>
        <div id="minter-admins-content" class="content">
            <div id="minter-admin-list"></div>
        </div>
        <h2 id="dev-admins-header" class="collapsible">
            Developer Admins (<span id="total-dev-admins"></span>) - Group ID 1
        </h2>
        <div id="dev-admins-content" class="content">
            <div id="dev-admin-list"></div>
        </div>
    </div>
    <!-- New div for rewards by tier -->
    <div id="rewards-by-tier" style="display:none;">
        <!-- Rewards per tier will be inserted here -->
    </div>
    <!-- Add search input field -->
    <p>
        <input type="text" id="search-input" placeholder="Search members...">
    </p>
    <div id="members-by-level" style="display:none;">
        <!-- Members grouped by level will be inserted here -->
    </div>
    <script>
        // JavaScript code

        const membersByLevel = {};
        let minterAdmins = [];
        let devAdmins = [];
        let tierData = {};

        const loadingDiv = document.getElementById('loading');
        const summaryDiv = document.querySelector('.summary');
        const membersByLevelContainer = document.getElementById('members-by-level');
        const progressDiv = document.getElementById('progress');
        const progressText = document.getElementById('progress-text');
        const progressBar = document.getElementById('progress-bar');
        const estimatedTimeDiv = document.getElementById('estimated-time');
        const minterAdminListDiv = document.getElementById('minter-admin-list');
        const devAdminListDiv = document.getElementById('dev-admin-list');
        const rewardsByTierContainer = document.getElementById('rewards-by-tier');
        const searchInput = document.getElementById('search-input');

        // Theme variables from Q-Apps
        const theme = typeof _qdnTheme !== 'undefined' ? _qdnTheme : 'light';

        // Set CSS variables based on theme
        if (theme === 'dark') {
            document.documentElement.style.setProperty('--background-color', '#001f3f');
            document.documentElement.style.setProperty('--text-color', '#e0e0e0');
            document.documentElement.style.setProperty('--link-color', 'dodgerblue');
        } else {
            document.documentElement.style.setProperty('--background-color', 'white');
            document.documentElement.style.setProperty('--text-color', '#333');
            document.documentElement.style.setProperty('--link-color', 'dodgerblue');
        }

        (async () => {
            try {
                // Fetch the group members data
                const response = await fetch('/groups/members/694');
                if (!response.ok) throw new Error('Failed to fetch group members');
                const data = await response.json();

                const memberCount = data.memberCount;
                const minterAdminCount = data.adminCount;
                const members = data.members; // Array of member objects

                // Extract minter admin members from the members array
                minterAdmins = members.filter(member => member.isAdmin);

                // Display the total members and admins
                document.getElementById('total-members').textContent = memberCount;
                document.getElementById('total-minter-admins').textContent = minterAdminCount;

                const devResponse = await fetch('/groups/members/1');
                if (!devResponse.ok) throw new Error('Failed to fetch dev group members');
                const devData = await devResponse.json();
                const devAdminCount = devData.adminCount;
                const devMembers = devData.members; // Array of dev group member objects
                devAdmins = devMembers.filter(member => member.isAdmin);
                document.getElementById('total-dev-admins').textContent = devAdminCount;
                // Once the DOM elements exist, attach click handlers for toggling:
                document.getElementById('minter-admins-header').addEventListener('click', function() {
                    const contentDiv = document.getElementById('minter-admins-content');
                    if (contentDiv.style.display === 'block') {
                        contentDiv.style.display = 'none';
                    } else {
                        contentDiv.style.display = 'block';
                    }
                });
                document.getElementById('dev-admins-header').addEventListener('click', function() {
                    const contentDiv = document.getElementById('dev-admins-content');
                    if (contentDiv.style.display === 'block') {
                        contentDiv.style.display = 'none';
                    } else {
                        contentDiv.style.display = 'block';
                    }
                });
                devAdmins = await Promise.all(
                    devAdmins.map(async (adminObj) => {
                        return processDevAdmin(adminObj);
                    })
                );

                summaryDiv.style.display = 'block';

                // Update block info and get necessary variables
                const blockInfo = await updateBlockInfo();

                // Total payout reward for next payout
                const totalPayoutReward = 1000 * blockInfo.currentBlockReward;

                // Define tiers
                const tiers = [
                    { levels: [1,2], percentage: 0.06, name: 'Levels 1-2' },
                    { levels: [3,4], percentage: 0.13, name: 'Levels 3-4' },
                    { levels: [5,6], percentage: 0.19, name: 'Levels 5-6' },
                    { levels: [7,8], percentage: 0.26, name: 'Levels 7-8' },
                    { levels: [9,10], percentage: 0.32, name: 'Levels 9-10' },
                ];

                tierData = {};

                tiers.forEach(tier => {
                    tierData[tier.name] = {
                        percentage: tier.percentage,
                        levels: tier.levels,
                        memberCount: 0,
                        reward: 0,
                        rewardPerMember: 0
                    };
                });

                const startTime = Date.now();
                // Process each member
                const totalMembers = members.length;
                let processedMembers = 0;

                // Limit the number of concurrent fetches
                const CONCURRENT_LIMIT = 10;
                let index = 0;

                async function processNext() {
                    if (index >= members.length) {
                        return;
                    }
                    const memberObj = members[index];
                    index++;
                    await processMember(memberObj);
                    processedMembers++;
                    const percentage = ((processedMembers / totalMembers) * 100).toFixed(2);
                    const elapsedTime = Date.now() - startTime; // in milliseconds
                    const averageTimePerMember = elapsedTime / processedMembers;
                    const estimatedTotalTime = averageTimePerMember * totalMembers;
                    const estimatedTimeRemaining = estimatedTotalTime - elapsedTime; // in milliseconds
                    progressText.textContent = `Processed ${processedMembers} of ${totalMembers} members (${percentage}%)`;
                    progressBar.style.width = `${percentage}%`;
                    estimatedTimeDiv.textContent = `Estimated Time Remaining: ${formatTime(estimatedTimeRemaining / 1000)}`;
                    await processNext();
                }

                // Start initial concurrent fetches
                const initialPromises = [];
                for (let i = 0; i < CONCURRENT_LIMIT; i++) {
                    initialPromises.push(processNext());
                }

                await Promise.all(initialPromises);

                // All members processed

                // This hides the progress indicators
                loadingDiv.textContent = '';
                membersByLevelContainer.style.display = 'block';
                progressDiv.style.display = 'none';

                // Now, display the data

                // Compute member counts per tier
                for (const level in membersByLevel) {
                    const levelNum = parseInt(level, 10);
                    const memberCountAtLevel = membersByLevel[level].length;
                    for (const tier of tiers) {
                        if (tier.levels.includes(levelNum)) {
                            tierData[tier.name].memberCount += memberCountAtLevel;
                            break;
                        }
                    }
                }

                // Compute rewards per tier
                for (const tierName in tierData) {
                    const tier = tierData[tierName];
                    tier.reward = totalPayoutReward * tier.percentage;
                    if (tier.memberCount > 0) {
                        tier.rewardPerMember = tier.reward / tier.memberCount;
                    } else {
                        tier.rewardPerMember = 0;
                    }
                }

                // Display the rewards per tier
                displayRewardsByTier();

                displayMinterAdmins();
                displayDevAdmins();
                displayMembersByLevel();

                loadingDiv.textContent = '';
                membersByLevelContainer.style.display = 'block';
                progressDiv.style.display = 'none';

            } catch (error) {
                console.error('Error loading data:', error);
                loadingDiv.textContent = `Error loading data: ${error}`;
            }
        })();

        async function updateBlockInfo() {
    try {
        document.getElementById('reload-button').disabled = true;
        loadingDiv.textContent = 'Loading data...';
        // Fetch the current block height
        const blockHeightResponse = await fetch('/blocks/height');
        if (!blockHeightResponse.ok) throw new Error('Failed to fetch block height');
        const currentBlockHeight = await blockHeightResponse.json();

        // Fetch the current block to get its timestamp
        const currentBlockResponse = await fetch(`/blocks/byheight/${currentBlockHeight}`);
        if (!currentBlockResponse.ok) throw new Error('Failed to fetch current block data');
        const currentBlockData = await currentBlockResponse.json();
        const currentBlockTimestamp = currentBlockData.timestamp;

        // Fetch the block at height (currentBlockHeight - 1000) to get its timestamp
        const previousBlockHeight = currentBlockHeight - 1000;
        if (previousBlockHeight <= 0) throw new Error('Not enough blocks to calculate average block time');
        const previousBlockResponse = await fetch(`/blocks/byheight/${previousBlockHeight}`);
        if (!previousBlockResponse.ok) throw new Error('Failed to fetch previous block data');
        const previousBlockData = await previousBlockResponse.json();
        const previousBlockTimestamp = previousBlockData.timestamp;

        // Calculate average block time in seconds per block
        const timeDifferenceInSeconds = (currentBlockTimestamp - previousBlockTimestamp) / 1000;
        const averageBlockTime = timeDifferenceInSeconds / 1000;

        // Calculate next payout block height
        const nextPayoutHeight = Math.ceil(currentBlockHeight / 1000) * 1000;

        // Calculate blocks until next payout
        const blocksUntilPayout = nextPayoutHeight - currentBlockHeight;

        // Estimate time until next payout in seconds
        const estimatedTimeUntilPayout = blocksUntilPayout * averageBlockTime;

        // Function to get the current block reward based on block height
        function getCurrentBlockReward(blockHeight) {
            if (blockHeight >= 3110401) {
                return 2.00;
            } else if (blockHeight >= 2851201) {
                return 2.25;
            } else if (blockHeight >= 2592001) {
                return 2.50;
            } else if (blockHeight >= 2332801) {
                return 2.75;
            } else if (blockHeight >= 2073601) {
                return 3.00;
            } else if (blockHeight >= 1814401) {
                return 3.25;
            } else if (blockHeight >= 1555201) {
                return 3.50;
            } else if (blockHeight >= 1296001) {
                return 3.75;
            } else if (blockHeight >= 1036801) {
                return 4.00;
            } else if (blockHeight >= 777601) {
                return 4.25;
            } else if (blockHeight >= 518401) {
                return 4.50;
            } else if (blockHeight >= 259201) {
                return 4.75;
            } else {
                return 5.00;
            }
        }

        const currentBlockReward = getCurrentBlockReward(nextPayoutHeight);

        // Display block and payout information
        document.getElementById('current-block-reward').textContent = `${currentBlockReward} QORT/Block`;
        document.getElementById('current-block-height').textContent = `Block ${currentBlockHeight}`;
        document.getElementById('next-payout-height').textContent = `Block ${nextPayoutHeight}`;
        document.getElementById('blocks-until-payout').textContent = `in ${blocksUntilPayout} Blocks`;
        document.getElementById('time-until-payout').textContent = `(about ${formatTime(estimatedTimeUntilPayout)})`;
        loadingDiv.textContent = '';
        document.getElementById('reload-button').disabled = false;

        // Return the necessary variables for further calculations
        return {
            currentBlockReward,
            currentBlockHeight,
            nextPayoutHeight,
            blocksUntilPayout,
            estimatedTimeUntilPayout
        };
    } catch (error) {
        console.error('Error updating block info:', error);
        loadingDiv.textContent = `Error updating block info: ${error}`;
        document.getElementById('reload-button').disabled = false;
    }
}

        async function processMember(memberObj) {
            try {
                const address = memberObj.member;
                const isAdmin = memberObj.isAdmin === true;

                // Fetch the address data to get the level
                let level = 'Unknown';
                try {
                    const addressDataResponse = await fetch(`/addresses/${address}`);
                    if (addressDataResponse.ok) {
                        const addressData = await addressDataResponse.json();
                        level = addressData.level;
                    } else {
                        console.error(`Error fetching address data for ${address}: ${addressDataResponse.statusText}`);
                    }
                } catch (error) {
                    console.error(`Error fetching address data for ${address}:`, error);
                }

                // Fetch the names data to get the name (if any)
                let name = null;
                try {
                    const namesDataResponse = await fetch(`/names/address/${address}`);
                    if (namesDataResponse.ok) {
                        const namesData = await namesDataResponse.json();
                        name = (namesData && namesData.length > 0) ? namesData[0].name : null;
                    } else {
                        console.error(`Error fetching names data for ${address}: ${namesDataResponse.statusText}`);
                    }
                } catch (error) {
                    console.error(`Error fetching names data for ${address}:`, error);
                }

                // Attempt to fetch the avatar image if the user has a name
                let avatarUrl = null;
                if (name) {
                    // The avatar image URL is "/arbitrary/THUMBNAIL/{NAME}/qortal_avatar"
                    const avatarImageUrl = `/arbitrary/THUMBNAIL/${encodeURIComponent(name)}/qortal_avatar`;
                    // Check if the image exists
                    try {
                        const avatarResponse = await fetch(avatarImageUrl);
                        if (avatarResponse.ok) {
                            avatarUrl = avatarImageUrl;
                        }
                    } catch (error) {
                        // Avatar image not found or error occurred
                        console.error(`Error fetching avatar for ${name}:`, error);
                    }
                }

                // Check for TRANSFER_PRIVS transaction
                const transferCheck = await fetch('/transactions/search?txType=TRANSFER_PRIVS&confirmationStatus=CONFIRMED&limit=0&address=' + address);
                const transferResponse = await transferCheck.json();
                let transferAddress = null;
                let transferName = null;
                
                if (transferResponse.length > 0) {
                    transferAddress = transferResponse[0].creatorAddress;
                    try {
                        const transferNamesDataResponse = await fetch(`/names/address/${transferAddress}`);
                        if (transferNamesDataResponse.ok) {
                            const transferNamesData = await transferNamesDataResponse.json();
                            transferName = (transferNamesData && transferNamesData.length > 0) ? transferNamesData[0].name : null;
                        } else {
                            console.error(`Error fetching names data for ${transferAddress}: ${transferNamesDataResponse.statusText}`);
                        }
                    } catch (error) {
                        console.error(`Error fetching names data for ${transferAddress}:`, error);
                    }
                }

                // Store the member data
                const memberData = {
                    address,
                    name,
                    level,
                    avatarUrl,
                    isAdmin,
                    transferAddress,
                    transferName
                };

                // Add the member to the appropriate level group
                if (!membersByLevel[level]) {
                    membersByLevel[level] = [];
                }
                membersByLevel[level].push(memberData);

                // Update admin data with full memberData
                if (isAdmin) {
                    const adminIndex = minterAdmins.findIndex(admin => admin.member === address);
                    if (adminIndex !== -1) {
                        minterAdmins[adminIndex] = { ...minterAdmins[adminIndex], ...memberData };
                    }
                }

            } catch (error) {
                console.error(`Error processing member ${memberObj.member}:`, error);
            }
        }

        async function processDevAdmin(adminObj) {
            try {
                const address = adminObj.member; // original property is .member
                let level = 'Unknown';
                let name = null;
                let avatarUrl = null;
                try {
                    const addressDataResponse = await fetch(`/addresses/${address}`);
                    if (addressDataResponse.ok) {
                        const addressData = await addressDataResponse.json();
        level = addressData.level;
      }
    } catch (err) {
      console.error(`Error fetching address data for ${address}:`, err);
    }
    
    // 2) Fetch names data => get name
    try {
      const namesDataResponse = await fetch(`/names/address/${address}`);
      if (namesDataResponse.ok) {
        const namesData = await namesDataResponse.json();
        name = (namesData && namesData.length > 0) ? namesData[0].name : null;
      }
    } catch (err) {
      console.error(`Error fetching names data for ${address}:`, err);
    }
    
    // 3) Check avatar
    if (name) {
      // The avatar image URL is "/arbitrary/THUMBNAIL/{NAME}/qortal_avatar"
      const avatarImageUrl = `/arbitrary/THUMBNAIL/${encodeURIComponent(name)}/qortal_avatar`;
      try {
        const avatarRes = await fetch(avatarImageUrl);
        if (avatarRes.ok) {
          avatarUrl = avatarImageUrl;
        }
      } catch (err) {
        console.error(`Error fetching dev avatar for ${name}:`, err);
      }
    }

    // Attach fields so that displayDevAdmins can use them
    // (We rename adminObj.member -> adminObj.address)
    adminObj.address = address;
    adminObj.name = name;
    adminObj.level = level;
    adminObj.avatarUrl = avatarUrl;

    return adminObj;
  } catch (err) {
    console.error(`Error in processDevAdmin():`, err);
    return adminObj; // fallback
            }
        }

        function displayMinterAdmins() {
            if (minterAdmins.length === 0) {
                const p = document.createElement('p');
                p.textContent = 'No minter admins found.';
                minterAdminListDiv.appendChild(p);
                return;
            }

            // Sort admins alphabetically by name, then by address
            minterAdmins.sort((a, b) => {
                if (a.name && b.name) {
                    return a.name.localeCompare(b.name);
                } else if (a.name) {
                    return -1;
                } else if (b.name) {
                    return 1;
                } else {
                    return a.address.localeCompare(b.address);
                }
            });

            minterAdmins.forEach(admin => {
                const minterAdminDiv = document.createElement('div');
                minterAdminDiv.classList.add('member');

                if (admin.avatarUrl) {
                    const img = document.createElement('img');
                    img.src = admin.avatarUrl;
                    img.alt = `${admin.name || admin.address}'s avatar`;
                    minterAdminDiv.appendChild(img);
                } else {
                    // Add invisible placeholder
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('placeholder');
                    minterAdminDiv.appendChild(placeholder);
                }

                const infoSpan = document.createElement('span');
                let displayText = '';
                if (admin.name) {
                    displayText = `${admin.name} (${admin.address}) - Level ${admin.level}`;
                } else {
                    displayText = `${admin.address} - Level ${admin.level}`;
                }
                infoSpan.textContent = displayText;
                infoSpan.classList.add('minter-admin');

                minterAdminDiv.appendChild(infoSpan);

                minterAdminListDiv.appendChild(minterAdminDiv);
            });
        }

        function displayDevAdmins() {
            // TODO - verify this code and adjust if needed, then uncomment the block
            if (devAdmins.length === 0) {
                const p = document.createElement('p');
                p.textContent = 'No developer admins found.';
                devAdminListDiv.appendChild(p);
                return;
            }

            // Sort dev admins alphabetically by name, then by address
            devAdmins.sort((a, b) => {
                if (a.name && b.name) {
                    return a.name.localeCompare(b.name);
                } else if (a.name) {
                    return -1;
                } else if (b.name) {
                    return 1;
                } else {
                    return a.address.localeCompare(b.address);
                }
            });

            devAdmins.forEach(admin => {
                const devAdminDiv = document.createElement('div');
                devAdminDiv.classList.add('member');

                if (admin.avatarUrl) {
                    const img = document.createElement('img');
                    img.src = admin.avatarUrl;
                    img.alt = `${admin.name || admin.address}'s avatar`;
                    devAdminDiv.appendChild(img);
                } else {
                    // Add invisible placeholder
                    const placeholder = document.createElement('div');
                    placeholder.classList.add('placeholder');
                    devAdminDiv.appendChild(placeholder);
                }

                const infoSpan = document.createElement('span');
                let displayText = '';
                if (admin.name) {
                    displayText = `${admin.name} (${admin.address}) - Level ${admin.level}`;
                } else {
                    displayText = `${admin.address} - Level ${admin.level}`;
                }
                infoSpan.textContent = displayText;
                infoSpan.classList.add('dev-admin');

                devAdminDiv.appendChild(infoSpan);

                devAdminListDiv.appendChild(devAdminDiv);
            });
        }

        // Add event listener to the search input
            searchInput.addEventListener('input', function() {
            const searchQuery = searchInput.value.trim().toLowerCase();
            displayMembersByLevel(searchQuery);
        });

        // Modified displayMembersByLevel function
        function displayMembersByLevel(searchQuery = '') {
            // Clear the container
            membersByLevelContainer.innerHTML = '';

            const levels = Object.keys(membersByLevel).sort((a, b) => a - b);

            levels.forEach(level => {
                const membersAtLevel = membersByLevel[level].slice(); // Copy the array
                // Sort members
                membersAtLevel.sort((a, b) => {
                    if (a.name && b.name) {
                        return a.name.localeCompare(b.name);
                    } else if (a.name) {
                        return -1;
                    } else if (b.name) {
                        return 1;
                    } else {
                        return a.address.localeCompare(b.address);
                    }
                });

                // Filter members based on search query
                const filteredMembers = membersAtLevel.filter(member => {
                    if (searchQuery === '') return true;
                    const name = member.name ? member.name.toLowerCase() : '';
                    const address = member.address.toLowerCase();
                    return name.includes(searchQuery) || address.includes(searchQuery);
                });

                if (filteredMembers.length === 0) {
                    // No members matching the search query at this level
                    return; // Skip this level
                }

                const levelGroup = document.createElement('div');
                levelGroup.classList.add('level-group');

                const levelHeader = document.createElement('h2');
                levelHeader.textContent = `Level ${level} Members (${filteredMembers.length})`;
                levelHeader.classList.add('collapsible');

                // Content div that will hold the list of members
                const contentDiv = document.createElement('div');
                contentDiv.classList.add('content');

                filteredMembers.forEach(member => {
                    const memberDiv = document.createElement('div');
                    memberDiv.classList.add('member');

                    if (member.avatarUrl) {
                        const img = document.createElement('img');
                        img.src = member.avatarUrl;
                        img.alt = `${member.name || member.address}'s avatar`;
                        memberDiv.appendChild(img);
                    } else {
                        // Add invisible placeholder
                        const placeholder = document.createElement('div');
                        placeholder.classList.add('placeholder');
                        memberDiv.appendChild(placeholder);
                    }

                    const nameSpan = document.createElement('span');
                    if (member.name) {
                        nameSpan.textContent = `${member.name} (${member.address})`;
                    } else {
                        nameSpan.textContent = member.address;
                    }

                    // Check if member is a dev admin...
                    if (devAdmins.some(admin => admin.address === member.address)) {
                        nameSpan.classList.add('dev-admin');
                    // ...if not, check if member is a minter admin
                    } else if (member.isAdmin) {
                        nameSpan.classList.add('minter-admin');
                    }

                    memberDiv.appendChild(nameSpan);
                    contentDiv.appendChild(memberDiv);

                    if (member.transferAddress) {
                        const transferDiv = document.createElement('div');
                        const placeholder = document.createElement('div');
                        placeholder.classList.add('placeholder');
                        transferDiv.appendChild(placeholder);

                        const transferSpan = document.createElement('span');
                        if (member.transferName) {
                            transferSpan.textContent = `TRANSFER_PRIVS from: ${member.transferName} (${member.transferAddress})`;
                        } else {
                            transferSpan.textContent = `TRANSFER_PRIVS from: (${member.transferAddress})`;
                        }
                        transferDiv.appendChild(transferSpan);
                        contentDiv.appendChild(transferDiv);
                    }

                    
                });

                // Add event listener to level header for collapsing/expanding
                levelHeader.addEventListener('click', function() {
                    this.classList.toggle('active');
                    if (contentDiv.style.display === 'block') {
                        contentDiv.style.display = 'none';
                    } else {
                        contentDiv.style.display = 'block';
                    }
                });

                // Expand the level by default if search query is not empty
                if (searchQuery !== '') {
                    contentDiv.style.display = 'block';
                }

                levelGroup.appendChild(levelHeader);
                levelGroup.appendChild(contentDiv);

                membersByLevelContainer.appendChild(levelGroup);
            });
        }

        // Function to format time from seconds to a readable format
        function formatTime(seconds) {
            const days = Math.floor(seconds / (24 * 3600));
            seconds %= (24 * 3600);
            const hours = Math.floor(seconds / 3600);
            seconds %= 3600;
            const minutes = Math.floor(seconds / 60);
            seconds = Math.floor(seconds % 60);
            let timeString = '';
            if (days > 0) timeString += days + 'd ';
            if (hours > 0 || days > 0) timeString += hours + 'h ';
            if (minutes > 0 || hours > 0 || days > 0) timeString += minutes + 'm ';
            timeString += seconds + 's';
            return timeString;
        }

        // Function to display rewards by tier
        function displayRewardsByTier() {
            for (const tierName in tierData) {
                const tier = tierData[tierName];

                const tierDiv = document.createElement('div');
                tierDiv.classList.add('tier');

                const header = document.createElement('h3');
                header.textContent = `${tierName} - ${tier.memberCount} Members`;
                tierDiv.appendChild(header);

                const rewardP = document.createElement('p');
                rewardP.textContent = `Total Reward for Tier: ${tier.reward.toFixed(2)} QORT`;
                tierDiv.appendChild(rewardP);

                const rewardPerMemberP = document.createElement('p');
                rewardPerMemberP.textContent = `Reward per Member: ${tier.rewardPerMember.toFixed(4)} QORT`;
                tierDiv.appendChild(rewardPerMemberP);

                rewardsByTierContainer.appendChild(tierDiv);
            }

            rewardsByTierContainer.style.display = 'block';
        }

        // Add event listener to the Reload button
        document.getElementById('reload-button').addEventListener('click', function() {
            updateBlockInfo();
        });
    </script>
</body>
</html>

